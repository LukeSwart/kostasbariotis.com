{"version":3,"sources":["webpack:///path---tag-dom-2b20e0fdf6efc107dec6.js","webpack:///./.cache/json/tag-dom.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/tag-dom.json","module","exports","pathContext","posts","excerpt","html","id","timeToRead","frontmatter","date","path","tags","title","tag","pagesSum","page"],"mappings":"AAAAA,cAAc,KAERC,iEACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAUC,QAAA,sPAAAC,KAAA,mtJAA8lJC,GAAA,yIAAAC,WAAA,EAAAC,aAAwiBC,KAAA,2BAAAC,KAAA,gCAAAC,KAAA,kBAAAC,MAAA,kCAA0IC,IAAA,MAAAC,SAAA,EAAAC,KAAA","file":"path---tag-dom-2b20e0fdf6efc107dec6.js","sourcesContent":["webpackJsonp([83],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/tag-dom.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"posts\":[{\"excerpt\":\"Have you ever tried to call   on a previously attached element and couldn't remove it? Did you maybe try to pass a function to   that is bound to another context? The context of the callback that we are passing to   is the same as the event...\",\"html\":\"<p>Have you ever tried to call <code>removeEventListener</code> on a previously attached element and couldn't remove it? Did you maybe try to pass a function to <code>addEventListener</code> that is bound to another context?</p>\\n<p>The context of the callback that we are passing to <code>addEventListener</code> is the same as the event.currentTarget when is being called. The problem is that when we bind the callback to another object, we can't remove it afterward.</p>\\n<p>Lets see an example:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>let element = document.createElement('button');\\n\\nlet callback = function (e) {\\n  console.assert(e.currentTarget === this);\\n}\\n\\nelement.addEventListener('click', callback);\\n\\nelement.dispatchEvent(new Event('click'));</code></pre>\\n      </div>\\n<p>In the example above, the assertion inside the callback is always going to be true. Great? Great. But that's not the case. Consider something like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>let Button = function () {\\n  this.el = document.createElement('button');\\n  this.addEvents();\\n}\\n\\nButton.prototype.addEvents = function () {\\n  this.el.addEventListener('click', this.clickHandler.bind(this));\\n}\\n\\nButton.prototype.clickHandler = function () {\\n  /* do something with this */\\n}</code></pre>\\n      </div>\\n<p>Great! I am trying to model my Button element and I need the event handlers to bind to the model itself.</p>\\n<p>Now let's try to remove the attached handler.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>let Button = function () {\\n\\n  this.el = document.createElement('button');\\n  this.addEvents();\\n}\\n\\nButton.prototype.addEvents = function () {\\n  this.el.addEventListener('click', this.clickHandler.bind(this));\\n}\\n\\nButton.prototype.removeEvents = function () {\\n  this.el.removeEventListener('click', this.clickHandler);\\n}\\n\\nButton.prototype.clickHandler = function () {\\n  /* do something with this */\\n}</code></pre>\\n      </div>\\n<p>The above won't work. Meaning that the <code>removeEventListener</code> won't actually remove the attached event handler. It will simply skip it. (And certainly if we bind again at the <code>removeEventListener</code> won't work). See, bind returns always a new function while <code>removeEventListener</code> and <code>addEventListener</code> second parameter must refer to the same function object.</p>\\n<p>So what do we do when we need to remove our attached event handlers at some point at runtime? Meet <code>handleEvent</code>, the default function that JavaScript looks for when tries to find a handler that has been attached to an event.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>let Button = function () {\\n\\n  this.el = document.createElement('button');\\n  this.addEvents();\\n}\\n\\nButton.prototype.addEvents = function () {\\n  this.el.addEventListener('click', this);\\n}\\n\\nButton.prototype.removeEvents = function () {\\n  this.el.removeEventListener('click', this);\\n}\\n\\nButton.prototype.handleEvent = function (e) {\\n  switch(e.type) {\\n    case 'click': {\\n     this.clickHandler(e);\\n    }\\n  }\\n}\\n\\nButton.prototype.clickHandler = function () {\\n  /* do something with this */\\n}</code></pre>\\n      </div>\\n<p>Note how I pass only <code>this</code> to the <code>addEventListener</code>/<code>removeEventListener</code> functions.  <code>addEventListener</code> accepts objects as well. This way, JavaScript will look for the <code>handleEvent</code> function and call it with the event passed.</p>\\n<p>This way we are able to remove the event listeners while <code>this</code> inside <code>clickHandler</code> is correctly set to the <code>Button</code> class.</p>\\n<p>Another possible solution would be to keep a reference to the binded function and then remove that.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>let Button = function () {\\n\\n  this.el = document.createElement('button');\\n  this.clickHandler = this.clickHandler.bind(this);\\n  this.addEvents();\\n}\\n\\nButton.prototype.addEvents = function () {\\n  this.el.addEventListener('click', this.clickHandler);\\n}\\n\\nButton.prototype.removeEvents = function () {\\n  this.el.removeEventListener('click', this.clickHandler);\\n}\\n\\nButton.prototype.clickHandler = function () {\\n  /* do something with this */\\n}</code></pre>\\n      </div>\\n<p>I still like the <code>handleEvent</code> function because I keep my event handlers in a single place and I don't pollute the constructor with meaningless bindings.</p>\\n<p>All of the above behaves exactly the same way using the class keyword of ES6.</p>\\n<p>Have you ever run into a similar situation? What did you do? Leave me a comment! :)</p>\",\"id\":\"/Users/Bariotis/Dev/develop/gatsby-blog-starter-kit/src/pages/removeeventlistener-and-this/index.md absPath of file >>> MarkdownRemark\",\"timeToRead\":3,\"frontmatter\":{\"date\":\"2017-01-17T14:46:20.000Z\",\"path\":\"/removeeventlistener-and-this\",\"tags\":\"javascript, DOM\",\"title\":\"removeEventListener and this\"}}],\"tag\":\"DOM\",\"pagesSum\":1,\"page\":1}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---tag-dom-2b20e0fdf6efc107dec6.js","module.exports = {\"pathContext\":{\"posts\":[{\"excerpt\":\"Have you ever tried to call   on a previously attached element and couldn't remove it? Did you maybe try to pass a function to   that is bound to another context? The context of the callback that we are passing to   is the same as the event...\",\"html\":\"<p>Have you ever tried to call <code>removeEventListener</code> on a previously attached element and couldn't remove it? Did you maybe try to pass a function to <code>addEventListener</code> that is bound to another context?</p>\\n<p>The context of the callback that we are passing to <code>addEventListener</code> is the same as the event.currentTarget when is being called. The problem is that when we bind the callback to another object, we can't remove it afterward.</p>\\n<p>Lets see an example:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>let element = document.createElement('button');\\n\\nlet callback = function (e) {\\n  console.assert(e.currentTarget === this);\\n}\\n\\nelement.addEventListener('click', callback);\\n\\nelement.dispatchEvent(new Event('click'));</code></pre>\\n      </div>\\n<p>In the example above, the assertion inside the callback is always going to be true. Great? Great. But that's not the case. Consider something like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>let Button = function () {\\n  this.el = document.createElement('button');\\n  this.addEvents();\\n}\\n\\nButton.prototype.addEvents = function () {\\n  this.el.addEventListener('click', this.clickHandler.bind(this));\\n}\\n\\nButton.prototype.clickHandler = function () {\\n  /* do something with this */\\n}</code></pre>\\n      </div>\\n<p>Great! I am trying to model my Button element and I need the event handlers to bind to the model itself.</p>\\n<p>Now let's try to remove the attached handler.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>let Button = function () {\\n\\n  this.el = document.createElement('button');\\n  this.addEvents();\\n}\\n\\nButton.prototype.addEvents = function () {\\n  this.el.addEventListener('click', this.clickHandler.bind(this));\\n}\\n\\nButton.prototype.removeEvents = function () {\\n  this.el.removeEventListener('click', this.clickHandler);\\n}\\n\\nButton.prototype.clickHandler = function () {\\n  /* do something with this */\\n}</code></pre>\\n      </div>\\n<p>The above won't work. Meaning that the <code>removeEventListener</code> won't actually remove the attached event handler. It will simply skip it. (And certainly if we bind again at the <code>removeEventListener</code> won't work). See, bind returns always a new function while <code>removeEventListener</code> and <code>addEventListener</code> second parameter must refer to the same function object.</p>\\n<p>So what do we do when we need to remove our attached event handlers at some point at runtime? Meet <code>handleEvent</code>, the default function that JavaScript looks for when tries to find a handler that has been attached to an event.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>let Button = function () {\\n\\n  this.el = document.createElement('button');\\n  this.addEvents();\\n}\\n\\nButton.prototype.addEvents = function () {\\n  this.el.addEventListener('click', this);\\n}\\n\\nButton.prototype.removeEvents = function () {\\n  this.el.removeEventListener('click', this);\\n}\\n\\nButton.prototype.handleEvent = function (e) {\\n  switch(e.type) {\\n    case 'click': {\\n     this.clickHandler(e);\\n    }\\n  }\\n}\\n\\nButton.prototype.clickHandler = function () {\\n  /* do something with this */\\n}</code></pre>\\n      </div>\\n<p>Note how I pass only <code>this</code> to the <code>addEventListener</code>/<code>removeEventListener</code> functions.  <code>addEventListener</code> accepts objects as well. This way, JavaScript will look for the <code>handleEvent</code> function and call it with the event passed.</p>\\n<p>This way we are able to remove the event listeners while <code>this</code> inside <code>clickHandler</code> is correctly set to the <code>Button</code> class.</p>\\n<p>Another possible solution would be to keep a reference to the binded function and then remove that.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>let Button = function () {\\n\\n  this.el = document.createElement('button');\\n  this.clickHandler = this.clickHandler.bind(this);\\n  this.addEvents();\\n}\\n\\nButton.prototype.addEvents = function () {\\n  this.el.addEventListener('click', this.clickHandler);\\n}\\n\\nButton.prototype.removeEvents = function () {\\n  this.el.removeEventListener('click', this.clickHandler);\\n}\\n\\nButton.prototype.clickHandler = function () {\\n  /* do something with this */\\n}</code></pre>\\n      </div>\\n<p>I still like the <code>handleEvent</code> function because I keep my event handlers in a single place and I don't pollute the constructor with meaningless bindings.</p>\\n<p>All of the above behaves exactly the same way using the class keyword of ES6.</p>\\n<p>Have you ever run into a similar situation? What did you do? Leave me a comment! :)</p>\",\"id\":\"/Users/Bariotis/Dev/develop/gatsby-blog-starter-kit/src/pages/removeeventlistener-and-this/index.md absPath of file >>> MarkdownRemark\",\"timeToRead\":3,\"frontmatter\":{\"date\":\"2017-01-17T14:46:20.000Z\",\"path\":\"/removeeventlistener-and-this\",\"tags\":\"javascript, DOM\",\"title\":\"removeEventListener and this\"}}],\"tag\":\"DOM\",\"pagesSum\":1,\"page\":1}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/tag-dom.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/tag-dom.json\n// module chunks = 83"],"sourceRoot":""}