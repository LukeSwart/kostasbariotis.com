webpackJsonp([72],{"./node_modules/json-loader/index.js!./.cache/json/tag-dom.json":function(e,t){e.exports={pathContext:{posts:[{excerpt:"Have you ever tried to call   on a previously attached element and couldn't remove it? Did you maybe try to pass a function to   that is bound to another context? The context of the callback that we are passing to   is the same as the event...",html:"<p>Have you ever tried to call <code>removeEventListener</code> on a previously attached element and couldn't remove it? Did you maybe try to pass a function to <code>addEventListener</code> that is bound to another context?</p>\n<p>The context of the callback that we are passing to <code>addEventListener</code> is the same as the event.currentTarget when is being called. The problem is that when we bind the callback to another object, we can't remove it afterward.</p>\n<p>Lets see an example:</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-none\"><code>let element = document.createElement('button');\n\nlet callback = function (e) {\n  console.assert(e.currentTarget === this);\n}\n\nelement.addEventListener('click', callback);\n\nelement.dispatchEvent(new Event('click'));</code></pre>\n      </div>\n<p>In the example above, the assertion inside the callback is always going to be true. Great? Great. But that's not the case. Consider something like this:</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-none\"><code>let Button = function () {\n  this.el = document.createElement('button');\n  this.addEvents();\n}\n\nButton.prototype.addEvents = function () {\n  this.el.addEventListener('click', this.clickHandler.bind(this));\n}\n\nButton.prototype.clickHandler = function () {\n  /* do something with this */\n}</code></pre>\n      </div>\n<p>Great! I am trying to model my Button element and I need the event handlers to bind to the model itself.</p>\n<p>Now let's try to remove the attached handler.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-none\"><code>let Button = function () {\n\n  this.el = document.createElement('button');\n  this.addEvents();\n}\n\nButton.prototype.addEvents = function () {\n  this.el.addEventListener('click', this.clickHandler.bind(this));\n}\n\nButton.prototype.removeEvents = function () {\n  this.el.removeEventListener('click', this.clickHandler);\n}\n\nButton.prototype.clickHandler = function () {\n  /* do something with this */\n}</code></pre>\n      </div>\n<p>The above won't work. Meaning that the <code>removeEventListener</code> won't actually remove the attached event handler. It will simply skip it. (And certainly if we bind again at the <code>removeEventListener</code> won't work). See, bind returns always a new function while <code>removeEventListener</code> and <code>addEventListener</code> second parameter must refer to the same function object.</p>\n<p>So what do we do when we need to remove our attached event handlers at some point at runtime? Meet <code>handleEvent</code>, the default function that JavaScript looks for when tries to find a handler that has been attached to an event.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-none\"><code>let Button = function () {\n\n  this.el = document.createElement('button');\n  this.addEvents();\n}\n\nButton.prototype.addEvents = function () {\n  this.el.addEventListener('click', this);\n}\n\nButton.prototype.removeEvents = function () {\n  this.el.removeEventListener('click', this);\n}\n\nButton.prototype.handleEvent = function (e) {\n  switch(e.type) {\n    case 'click': {\n     this.clickHandler(e);\n    }\n  }\n}\n\nButton.prototype.clickHandler = function () {\n  /* do something with this */\n}</code></pre>\n      </div>\n<p>Note how I pass only <code>this</code> to the <code>addEventListener</code>/<code>removeEventListener</code> functions.  <code>addEventListener</code> accepts objects as well. This way, JavaScript will look for the <code>handleEvent</code> function and call it with the event passed.</p>\n<p>This way we are able to remove the event listeners while <code>this</code> inside <code>clickHandler</code> is correctly set to the <code>Button</code> class.</p>\n<p>Another possible solution would be to keep a reference to the binded function and then remove that.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-none\"><code>let Button = function () {\n\n  this.el = document.createElement('button');\n  this.clickHandler = this.clickHandler.bind(this);\n  this.addEvents();\n}\n\nButton.prototype.addEvents = function () {\n  this.el.addEventListener('click', this.clickHandler);\n}\n\nButton.prototype.removeEvents = function () {\n  this.el.removeEventListener('click', this.clickHandler);\n}\n\nButton.prototype.clickHandler = function () {\n  /* do something with this */\n}</code></pre>\n      </div>\n<p>I still like the <code>handleEvent</code> function because I keep my event handlers in a single place and I don't pollute the constructor with meaningless bindings.</p>\n<p>All of the above behaves exactly the same way using the class keyword of ES6.</p>\n<p>Have you ever run into a similar situation? What did you do? Leave me a comment! :)</p>",id:"/Users/Bariotis/Dev/develop/gatsby-blog-starter-kit/src/pages/removeeventlistener-and-this/index.md absPath of file >>> MarkdownRemark",timeToRead:3,frontmatter:{date:"2017-01-17T14:46:20.000Z",path:"/removeeventlistener-and-this",tags:"javascript, DOM",title:"removeEventListener and this",draft:null}}],tag:"DOM",pagesSum:1,page:1}}}});
//# sourceMappingURL=path---tag-dom-fe975bdd6387803d0b84.js.map